---
title: "Three Ways of Storing and Accessing Lots of Images in Python"
author: "Muhammad Zaki Abdillah"
date: "2024-05-28"
output:
  pdf_document: default
  html_document: default
---

Kode berikut membuka setiap berkas batch dan memuat semua gambar ke dalam larik NumPy:


import numpy as np
import pickle
from pathlib import Path


a. numpy digunakan untuk operasi numerik, terutama dalam manipulasi array.
b. pickle digunakan untuk memuat data yang disimpan dalam format pickle (serialisasi/deserialisasi objek Python).
c. Path dari pathlib digunakan untuk memanipulasi path file secara mudah dan platform-independen.

# Path to the unzipped CIFAR data
data_dir = Path("/content/cifar-10-batches-py-20240421T062357Z-001.zip")

# Unpickle function provided by the CIFAR hosts
def unpickle(file):
    with open(file, "rb") as fo:
        dict = pickle.load(fo, encoding="bytes")
    return dict
    
#Fungsi unpickle digunakan untuk membuka file yang telah diserialisasi dengan pickle. Ini membaca file dalam mode biner ("rb") dan mengembalikan kamus (dictionary) yang berisi data

images, labels = [], []
for batch in data_dir.glob("data_batch_*"):
    batch_data = unpickle(batch)
    for i, flat_im in enumerate(batch_data[b"data"]):
        im_channels = []
        # Each image is flattened, with channels in order of R, G, B
        for j in range(3):
            im_channels.append(
                flat_im[j * 1024 : (j + 1) * 1024].reshape((32, 32))
            )
        # Reconstruct the original image
        images.append(np.dstack((im_channels)))
        # Save the label
        labels.append(batch_data[b"labels"][i])


print("Loaded CIFAR-10 training set:")
print(f" - np.shape(images)     {np.shape(images)}")
print(f" - np.shape(labels)     {np.shape(labels)}")


#Output 
Loaded CIFAR-10 training set:
 - np.shape(images)     (0,)
 - np.shape(labels)     (0,)


a. images dan labels adalah list kosong yang akan diisi dengan gambar dan label. 

b. data_dir.glob("data_batch_*") mencari semua file yang sesuai dengan pola data_batch_* dalam direktori data_dir. 

c. unpickle(batch) memuat data dari file batch menggunakan fungsi unpickle. 

d. batch_data[b"data"] berisi gambar-gambar yang diflatten ke dalam array 1D. batch_data[b"labels"] berisi label yang sesuai dengan setiap gambar.

e. Loop pertama (for i, flat_im in enumerate(batch_data[b"data"]):) iterasi melalui setiap gambar yang diflatten. 

f. Loop kedua (for j in range(3):) iterasi melalui setiap channel warna (Red, Green, Blue) dan memisahkan channel-channel tersebut. Masing-masing channel memiliki 1024 elemen (32x32). 

g. reshape((32, 32)) mengubah array 1D kembali menjadi 2D dengan ukuran 32x32. np.dstack((im_channels)) menggabungkan ketiga channel (R, G, B) menjadi satu gambar berwarna dengan ukuran 32x32x3. 

h. Gambar hasil penggabungan ditambahkan ke list images dan label ditambahkan ke list labels.

#Kode ini bertujuan untuk membuka setiap berkas batch dari dataset CIFAR-10 yang telah di-unzip dan memuat semua gambar ke dalam larik NumPy.

#Setup for Storing Images on Disk

$ pip install Pillow

Pillow: Paket Python untuk pemrosesan gambar.

#Getting Started With LMDB

$ pip install lmdb

lmdb: Lightning Memory-Mapped Database, sebuah library untuk database kinerja tinggi.

#Getting Started With HDF5

$ pip install h5py

h5py: Antarmuka Python untuk format file HDF5 (Hierarchical Data Format version 5), digunakan untuk menyimpan data ilmiah.

#Storing a Single Image
from pathlib import Path

disk_dir = Path("data/disk/")
lmdb_dir = Path("data/lmdb/")
hdf5_dir = Path("data/hdf5/")


1. Impor Path dari pathlib:Ini mengimpor kelas Path dari pustaka pathlib, yang memungkinkan kita membuat dan memanipulasi objek jalur berkas.

2. Membuat objek Path untuk direktori disk, LMDB, dan HDF5: - - -disk_dir, lmdb_dir, dan hdf5_dir adalah objek jalur yang mewakili direktori di sistem berkas.
-Path() digunakan untuk membuat objek jalur dari string yang diberikan. Dalam hal ini, string tersebut adalah jalur relatif dari direktori saat ini ke direktori yang ditentukan.
Objek jalur akan mewakili jalur di sistem berkas yang digunakan dalam kode selanjutnya, seperti membuat, membaca, atau menulis berkas.

#
disk_dir.mkdir(parents=True, exist_ok=True)
lmdb_dir.mkdir(parents=True, exist_ok=True)
hdf5_dir.mkdir(parents=True, exist_ok=True)

1. Membuat direktori diskritori dengan mkdir(): 
-mkdir() adalah metode yang digunakan untuk membuat direktori baru di sistem berkas.
-Argumen parents=True menunjukkan bahwa jika direktori induk dari direktori yang akan dibuat tidak ada, maka metode mkdir() akan membuatnya juga. Dalam konteks ini, parents=True memungkinkan pembuatan direktori yang bersarang, seperti saat direktori "data" belum ada, maka akan dibuat bersamaan dengan direktori "disk".
-Argumen exist_ok=True menunjukkan bahwa jika direktori yang akan dibuat sudah ada, maka tidak akan muncul pesan kesalahan. Dengan kata lain, jika direktori "disk" sudah ada, perintah ini tidak akan memunculkan kesalahan, sehingga tidak ada tindakan yang diambil.

#Storing to Disk

from PIL import Image
import csv

def store_single_disk(image, image_id, label):
    """ Stores a single image as a .png file on disk.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    Image.fromarray(image).save(disk_dir / f"{image_id}.png")

    with open(disk_dir / f"{image_id}.csv", "wt") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        writer.writerow([label])

1. Impor pustaka yang diperlukan:
-PIL digunakan untuk memanipulasi gambar.
csv digunakan untuk menulis label gambar ke dalam file CSV.

2. Definisi fungsi store_single_disk:
-Ini adalah definisi fungsi yang menerima tiga parameter: image, image_id, dan label.
-image adalah array gambar dengan bentuk (32, 32, 3) yang akan disimpan.
-image_id adalah ID unik untuk gambar.
-Label adalah label untuk gambar tersebut.

3. Menyimpan gambar sebagai file .png di -disk:Image.fromarray(image) mengonversi array gambar menjadi objek gambar dari pustaka PIL.
-save(disk_dir / f"{image_id}.png") menyimpan gambar ke dalam file -png dengan nama file yang sesuai dengan image_id, dalam direktori yang ditentukan oleh disk_dir.

4.Menyimpan label sebagai file .csv di disk:
-open(disk_dir / f"{image_id}.csv", "wt") membuka file CSV untuk ditulis dengan nama file yang sesuai dengan image_id, dalam direktori yang ditentukan oleh disk_dir.
-csv.writer() digunakan untuk membuat objek penulis CSV.
-writer.writerow([label]) menulis label gambar ke dalam file CSV. -Label tersebut diwakili sebagai satu elemen dalam list.

#Storing to LMDB

class CIFAR_Image:
    def _init_(self, image, label):
        # Dimensions of image for reconstruction - not really necessary 
        # for this dataset, but some datasets may include images of 
        # varying sizes
        self.channels = image.shape[2]
        self.size = image.shape[:2]

        self.image = image.tobytes()
        self.label = label

    def get_image(self):
        """ Returns the image as a numpy array. """
        image = np.frombuffer(self.image, dtype=np.uint8)
        return image.reshape(*self.size, self.channels)

Konstruktor (__init__):
  self.channels = image.shape[2]: Menyimpan jumlah channel dari gambar (3 untuk gambar berwarna).
  self.size = image.shape[:2]: Menyimpan dimensi gambar (tinggi dan lebar).
  self.image = image.tobytes(): Mengonversi array gambar ke byte string untuk penyimpanan yang efisien.
  self.label = label: Menyimpan label gambar.
  
Metode get_image:
  image = np.frombuffer(self.image, dtype=np.uint8): Membaca byte string kembali menjadi array numpy.
  return image.reshape(*self.size, self.channels): Mengubah bentuk array menjadi dimensi asli gambar.

#
import lmdb
import pickle

def store_single_lmdb(image, image_id, label):
    """ Stores a single image to a LMDB.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    map_size = image.nbytes * 10

    # Create a new LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), map_size=map_size)

    # Start a new write transaction
    with env.begin(write=True) as txn:
        # All key-value pairs need to be strings
        value = CIFAR_Image(image, label)
        key = f"{image_id:08}"
        txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()

a. map_size = image.nbytes * 10: Menentukan ukuran peta memori yang digunakan oleh LMDB. image.nbytes mengembalikan jumlah byte yang digunakan oleh array gambar. Ini dikalikan 10 sebagai buffer.

b. env = lmdb.open(str(lmdb_dir / f"single_lmdb"), map_size=map_size): Membuka lingkungan LMDB dengan ukuran peta yang ditentukan.

c. with env.begin(write=True) as txn: Memulai transaksi penulisan.

d. value = CIFAR_Image(image, label): Membuat objek CIFAR_Image dari gambar dan label.

e. key = f"{image_id:08}": Membuat kunci untuk item dalam LMDB. Kunci ini diisi nol di sebelah kiri hingga delapan digit.

f. txn.put(key.encode("ascii"), pickle.dumps(value)): Menyimpan objek CIFAR_Image yang telah dipickel dalam LMDB dengan kunci yang sesuai.
g. env.close(): Menutup lingkungan LMDB.

#Storing With HDF5


import h5py

def store_single_hdf5(image, image_id, label):
    """ Stores a single image to an HDF5 file.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "w")

    # Create a dataset in the file
    dataset = file.create_dataset(
        "image", np.shape(image), h5py.h5t.STD_U8BE, data=image
    )
    meta_set = file.create_dataset(
        "meta", np.shape(label), h5py.h5t.STD_U8BE, data=label
    )
    file.close()

- h5py: Library untuk bekerja dengan file HDF5, yang digunakan untuk menyimpan data ilmiah dalam format yang efisien dan fleksibel.
- Membuka file HDF5 baru untuk menulis ("w").
- Membuat dataset untuk gambar dengan nama "image" dan metadata (label) dengan nama "meta".
- Menyimpan gambar dan label dalam dataset tersebut.
- Kamus _store_single_funcs memetakan metode penyimpanan ke fungsi yang sesuai (disk, lmdb, hdf5).
- timeit untuk mengukur waktu yang diperlukan untuk menyimpan satu gambar menggunakan setiap metode.
- setup="image=images[0]; label=labels[0]" memastikan bahwa image dan label diatur sebelum menjalankan fungsi.
- number=1 berarti setiap fungsi dijalankan sekali.
- globals=globals() memastikan bahwa fungsi memiliki akses ke variabel global.


Output:

Method: disk, Time usage: 1.23456789
Method: lmdb, Time usage: 2.3456789
Method: hdf5, Time usage: 3.45678901

contoh output dari kode diatas, di mana waktu eksekusi (dalam detik) untuk setiap metode penyimpanan.

#Storing Many Images

store_many_disk(images, labels):
    """ Stores an array of images to disk
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    # Save all the images one by one
    for i, image in enumerate(images):
        Image.fromarray(image).save(disk_dir / f"{i}.png")

    # Save all the labels to the csv file
    with open(disk_dir / f"{num_images}.csv", "w") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for label in labels:
            # This typically would be more than just one value per row
            writer.writerow([label])

def store_many_lmdb(images, labels):
    """ Stores an array of images to LMDB.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    map_size = num_images * images[0].nbytes * 10

    # Create a new LMDB DB for all the images
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), map_size=map_size)

    # Same as before — but let's write all the images in a single transaction
    with env.begin(write=True) as txn:
        for i in range(num_images):
            # All key-value pairs need to be Strings
            value = CIFAR_Image(images[i], labels[i])
            key = f"{i:08}"
            txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()

def store_many_hdf5(images, labels):
    """ Stores an array of images to HDF5.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "w")

    # Create a dataset in the file
    dataset = file.create_dataset(
        "images", np.shape(images), h5py.h5t.STD_U8BE, data=images
    )
    meta_set = file.create_dataset(
        "meta", np.shape(labels), h5py.h5t.STD_U8BE, data=labels
    )
    file.close()

Fungsi-fungsi ini bertujuan untuk menyimpan banyak gambar ke dalam format penyimpanan yang berbeda (disk, LMDB, HDF5).
Berikut penjelasan rinci dari kode yang Anda berikan untuk menyimpan array gambar dan label ke dalam tiga format berbeda: disk, LMDB, dan HDF5.

### Fungsi Menyimpan Banyak Gambar ke Disk
```python
def store_many_disk(images, labels):
    """ Stores an array of images to disk
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    # Save all the images one by one
    for i, image in enumerate(images):
        Image.fromarray(image).save(disk_dir / f"{i}.png")

    # Save all the labels to the csv file
    with open(disk_dir / f"{num_images}.csv", "w") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for label in labels:
            # This typically would be more than just one value per row
            writer.writerow([label])
```
- **Tujuan**: Menyimpan array gambar dan label ke dalam format file di disk.
- **Parameter**:
  - `images`: Array dari gambar dengan bentuk `(N, 32, 32, 3)` dimana `N` adalah jumlah gambar.
  - `labels`: Array dari label dengan bentuk `(N, 1)` dimana `N` adalah jumlah label.
- **Langkah-langkah**:
  - Menentukan jumlah gambar `num_images`.
  - Menyimpan setiap gambar satu per satu sebagai file PNG menggunakan `Image.fromarray(image).save(disk_dir / f"{i}.png")`.
  - Membuka file CSV untuk menyimpan semua label.
  - Menulis setiap label ke file CSV menggunakan `csv.writer`.

### Fungsi Menyimpan Banyak Gambar ke LMDB
```python
def store_many_lmdb(images, labels):
    """ Stores an array of images to LMDB.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    map_size = num_images * images[0].nbytes * 10

    # Create a new LMDB DB for all the images
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), map_size=map_size)

    # Same as before — but let's write all the images in a single transaction
    with env.begin(write=True) as txn:
        for i in range(num_images):
            # All key-value pairs need to be Strings
            value = CIFAR_Image(images[i], labels[i])
            key = f"{i:08}"
            txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()
```
- **Tujuan**: Menyimpan array gambar dan label ke dalam database LMDB.
- **Parameter**:
  - `images`: Array dari gambar dengan bentuk `(N, 32, 32, 3)` dimana `N` adalah jumlah gambar.
  - `labels`: Array dari label dengan bentuk `(N, 1)` dimana `N` adalah jumlah label.
- **Langkah-langkah**:
  - Menentukan jumlah gambar `num_images`.
  - Menghitung `map_size` untuk LMDB berdasarkan jumlah gambar dan ukuran byte tiap gambar.
  - Membuka lingkungan LMDB dengan ukuran peta yang ditentukan menggunakan `lmdb.open`.
  - Memulai transaksi penulisan dan menyimpan setiap gambar dan label sebagai objek `CIFAR_Image` yang telah di-pickle.
  - Menutup lingkungan LMDB.

### Fungsi Menyimpan Banyak Gambar ke HDF5
```python
def store_many_hdf5(images, labels):
    """ Stores an array of images to HDF5.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)

    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "w")

    # Create a dataset in the file
    dataset = file.create_dataset(
        "images", np.shape(images), h5py.h5t.STD_U8BE, data=images
    )
    meta_set = file.create_dataset(
        "meta", np.shape(labels), h5py.h5t.STD_U8BE, data=labels
    )
    file.close()
```
- **Tujuan**: Menyimpan array gambar dan label ke dalam file HDF5.
- **Parameter**:
  - `images`: Array dari gambar dengan bentuk `(N, 32, 32, 3)` dimana `N` adalah jumlah gambar.
  - `labels`: Array dari label dengan bentuk `(N, 1)` dimana `N` adalah jumlah label.
- **Langkah-langkah**:
  - Menentukan jumlah gambar `num_images`.
  - Membuka file HDF5 baru untuk menulis (`"w"`).
  - Membuat dataset untuk gambar dengan nama `"images"` dan metadata (label) dengan nama `"meta"`.
  - Menyimpan semua gambar dan label dalam dataset tersebut.
  - Menutup file HDF5.

Output: Tidak ada output yang langsung terlihat dari fungsi-fungsi ini. Mereka akan menyimpan gambar-gambar dan labelnya sesuai dengan format penyimpanan yang ditentukan.

#Preparing the Dataset
cutoffs = [10, 100, 1000, 10000, 100000]

# Let's double our images so that we have 100,000
images = np.concatenate((images, images), axis=0)
labels = np.concatenate((labels, labels), axis=0)

# Make sure you actually have 100,000 images and labels
print(np.shape(images))
print(np.shape(labels))

Berikut adalah langkah-langkah dan output dari potongan kode tersebut:

### Langkah-langkah:
1. *Membuat daftar cutoffs:*
   python
   cutoffs = [10, 100, 1000, 10000, 100000]

   - cutoffs adalah daftar yang berisi nilai-nilai yang akan digunakan sebagai batas jumlah gambar.

2. *Menggandakan jumlah gambar:*
   python
   images = np.concatenate((images, images), axis=0)
   labels = np.concatenate((labels, labels), axis=0)

   - np.concatenate() digunakan untuk menggabungkan dua larik gambar dan label secara berurutan ke dalam satu larik.
   - axis=0 menunjukkan bahwa penggabungan dilakukan menurut baris (menambahkan gambar dan label ke bawah).

3. *Memastikan jumlah gambar dan label:*
   python
   print(np.shape(images))
   print(np.shape(labels))

   - np.shape() digunakan untuk mendapatkan dimensi dari larik gambar dan label.
   - Ini mencetak dimensi dari larik gambar dan label setelah proses penggandaan.

### Output (contoh):

(200000, 32, 32, 3)
(200000,)

- Output ini menunjukkan bahwa setelah penggandaan, kita sekarang memiliki 200.000 gambar dengan dimensi (32, 32, 3) dan 200.000 label.

#ExperimenT for Storing Many Images

_store_many_funcs = dict(
    disk=store_many_disk, lmdb=store_many_lmdb, hdf5=store_many_hdf5
)

from timeit import timeit

store_many_timings = {"disk": [], "lmdb": [], "hdf5": []}

for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "store_many_funcs[method](images, labels_)",
            setup="images_=images[:cutoff]; labels_=labels[:cutoff]",
            number=1,
            globals=globals(),
        )
        store_many_timings[method].append(t)

        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, Time usage: {t}")

Kode di atas digunakan untuk mengukur waktu yang diperlukan untuk menyimpan sejumlah gambar dan label menggunakan tiga metode penyimpanan yang berbeda (disk, LMDB, dan HDF5) untuk berbagai ukuran dataset. Berikut adalah penjelasan rinci dari kode tersebut:

### Menyusun Fungsi Penyimpanan dalam Kamus
```python
V_store_many_funcs = dict(
    disk=store_many_disk, lmdb=store_many_lmdb, hdf5=store_many_hdf5
)
```
- **V_store_many_funcs**: Kamus yang memetakan nama metode penyimpanan (`disk`, `lmdb`, `hdf5`) ke fungsi penyimpanan yang sesuai (`store_many_disk`, `store_many_lmdb`, `store_many_hdf5`).

### Mengimpor Modul `timeit`
```python
from timeit import timeit
```
- **timeit**: Modul yang digunakan untuk mengukur waktu eksekusi kode.

### Menyiapkan Struktur untuk Menyimpan Waktu Eksekusi
```python
store_many_timings = {"disk": [], "lmdb": [], "hdf5": []}
```
- **store_many_timings**: Kamus yang akan menyimpan daftar waktu eksekusi untuk setiap metode penyimpanan.

### Mengukur Waktu Eksekusi untuk Berbagai Ukuran Dataset
```python
for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_store_many_funcs[method](images_, labels_)",
            setup="images_=images[:cutoff]; labels_=labels[:cutoff]",
            number=1,
            globals=globals(),
        )
        store_many_timings[method].append(t)

        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, Time usage: {t}")
```
- **cutoffs**: Daftar yang berisi ukuran subset dari dataset gambar yang akan diuji. Misalnya, `[100, 500, 1000]` akan menguji waktu eksekusi untuk 100, 500, dan 1000 gambar.
- **Loop pertama** (`for cutoff in cutoffs`): Iterasi melalui setiap ukuran subset dari dataset.
- **Loop kedua** (`for method in ("disk", "lmdb", "hdf5")`): Iterasi melalui setiap metode penyimpanan.
- **timeit**:
  - **stmt**: String yang berisi kode untuk menyimpan subset dari gambar dan label menggunakan metode yang sedang diuji. `"_store_many_funcs[method](images_, labels_)"`
  - **setup**: String yang berisi kode untuk menyiapkan subset dari gambar dan label sebelum eksekusi. `"images_=images[:cutoff]; labels_=labels[:cutoff]"`
  - **number**: Jumlah pengulangan eksekusi. `number=1` berarti kode dieksekusi sekali untuk setiap pengujian.
  - **globals**: Membuat variabel global tersedia di dalam `timeit`.
- Menyimpan waktu eksekusi `t` dalam daftar yang sesuai di `store_many_timings`.
- Mencetak metode, ukuran subset, dan waktu eksekusi.

### Output (contoh):

Method: disk, Time usage: 5.67890123
Method: lmdb, Time usage: 6.78901234
Method: hdf5, Time usage: 7.89012345


import matplotlib.pyplot as plt

def plot_with_legend(
    x_range, y_data, legend_labels, x_label, y_label, title, log=False
):
    """ Displays a single plot with multiple datasets and matching legends.
        Parameters:
        --------------
        x_range         list of lists containing x data
        y_data          list of lists containing y values
        legend_labels   list of string legend labels
        x_label         x axis label
        y_label         y axis label
    """
    plt.style.use("seaborn-whitegrid")
    plt.figure(figsize=(10, 7))

    if len(y_data) != len(legend_labels):
        raise TypeError(
            "Error: number of data sets does not match number of labels."
        )

    all_plots = []
    for data, label in zip(y_data, legend_labels):
        if log:
            temp, = plt.loglog(x_range, data, label=label)
        else:
            temp, = plt.plot(x_range, data, label=label)
        all_plots.append(temp)

    plt.title(title)
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.legend(handles=all_plots)
    plt.show()

# Getting the store timings data to display
disk_x = store_many_timings["disk"]
lmdb_x = store_many_timings["lmdb"]
hdf5_x = store_many_timings["hdf5"]

plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Storage time",
    log=False,
)

plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Log storage time",
    log=True,
)


### Import dan Fungsi `plot_with_legend`
```python
import matplotlib.pyplot as plt

def plot_with_legend(
    x_range, y_data, legend_labels, x_label, y_label, title, log=False
):
    """ Displays a single plot with multiple datasets and matching legends.
        Parameters:
        --------------
        x_range         list of lists containing x data
        y_data          list of lists containing y values
        legend_labels   list of string legend labels
        x_label         x axis label
        y_label         y axis label
        title           title of the plot
        log             boolean indicating if log scale should be used
    """
    plt.style.use("seaborn-whitegrid")
    plt.figure(figsize=(10, 7))

    if len(y_data) != len(legend_labels):
        raise TypeError(
            "Error: number of data sets does not match number of labels."
        )

    all_plots = []
    for data, label in zip(y_data, legend_labels):
        if log:
            temp, = plt.loglog(x_range, data, label=label)
        else:
            temp, = plt.plot(x_range, data, label=label)
        all_plots.append(temp)

    plt.title(title)
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.legend(handles=all_plots)
    plt.show()
```

#### Penjelasan Fungsi `plot_with_legend`
- **Tujuan**: Membuat plot dengan beberapa dataset dan legenda yang sesuai.
- **Parameter**:
  - `x_range`: Daftar berisi data x untuk setiap dataset.
  - `y_data`: Daftar berisi data y untuk setiap dataset.
  - `legend_labels`: Daftar string yang berisi label legenda.
  - `x_label`: Label untuk sumbu x.
  - `y_label`: Label untuk sumbu y.
  - `title`: Judul plot.
  - `log`: Boolean yang menentukan apakah skala logaritmik digunakan atau tidak.

#### Langkah-langkah dalam Fungsi:
1. Mengatur gaya plot menggunakan `"seaborn-whitegrid"`.
2. Membuat figure dengan ukuran 10x7 inci.
3. Mengecek apakah jumlah dataset y dan label legenda cocok. Jika tidak, maka akan menimbulkan error `TypeError`.
4. Membuat list `all_plots` untuk menyimpan objek plot.
5. Iterasi melalui setiap dataset y dan labelnya:
   - Jika `log` adalah `True`, maka menggunakan `plt.loglog` untuk membuat plot dengan skala logaritmik.
   - Jika `log` adalah `False`, maka menggunakan `plt.plot` untuk membuat plot linear.
   - Menambahkan objek plot sementara ke `all_plots`.
6. Menambahkan judul, label sumbu x, dan label sumbu y.
7. Menambahkan legenda menggunakan `plt.legend`.
8. Menampilkan plot menggunakan `plt.show`.

### Mendapatkan Data Waktu Penyimpanan
```python
# Getting the store timings data to display
disk_x = store_many_timings["disk"]
lmdb_x = store_many_timings["lmdb"]
hdf5_x = store_many_timings["hdf5"]
```
- Mendapatkan data waktu penyimpanan dari kamus `store_many_timings` untuk masing-masing metode (`disk`, `lmdb`, `hdf5`).

### Memplot Waktu Penyimpanan
#### Plot Linear
```python
plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Storage time",
    log=False,
)
```
- Memanggil `plot_with_legend` dengan `log=False` untuk membuat plot dengan skala linear.
- Parameter yang diberikan:
  - `cutoffs`: Ukuran subset dari dataset yang digunakan sebagai data x.
  - `[disk_x, lmdb_x, hdf5_x]`: Data waktu penyimpanan untuk setiap metode sebagai data y.
  - `["PNG files", "LMDB", "HDF5"]`: Label legenda untuk setiap metode.
  - `"Number of images"`: Label untuk sumbu x.
  - `"Seconds to store"`: Label untuk sumbu y.
  - `"Storage time"`: Judul plot.

#### Plot Logaritmik

plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Log storage time",
    log=True,
)

- Memanggil `plot_with_legend` dengan `log=True` untuk membuat plot dengan skala logaritmik.
- Parameter yang diberikan sama seperti sebelumnya, dengan judul plot yang sedikit berbeda untuk menunjukkan bahwa ini adalah plot logaritmik (`"Log storage time"`).

### Output:
- Output berupa dua plot yang menampilkan waktu penyimpanan untuk setiap metode penyimpanan dalam detik, dengan sumbu x berlabel "Number of images" dan sumbu y berlabel "Seconds to store". Satu plot menggunakan skala linear dan yang lainnya menggunakan skala logaritmik. Legenda menunjukkan metode penyimpanan yang sesuai.

#Reading a Single Image

##Reading From Disk

def read_single_disk(image_id):
    """ Stores a single image to disk.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    image = np.array(Image.open(disk_dir / f"{image_id}.png"))

    with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        label = int(next(reader)[0])

    return image, label

Penjelasanmengenai fungsi `read_single_disk` yang digunakan untuk membaca gambar dan label terkait dari disk:

### Definisi Fungsi `read_single_disk`

def read_single_disk(image_id):
    """ Reads a single image from disk.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3)
        label       associated meta data, int label
    """
    image = np.array(Image.open(disk_dir / f"{image_id}.png"))

    with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        label = int(next(reader)[0])

    return image, label


### Penjelasan Fungsi
- **Tujuan**: Membaca sebuah gambar dan label yang terkait dari disk yang sebelumnya disimpan dengan metode penyimpanan disk (`store_single_disk`).
- **Parameter**:
  - `image_id`: ID unik untuk gambar yang ingin dibaca. ID ini digunakan untuk membangun nama file gambar (`.png`) dan file label (`.csv`).

### Langkah-langkah dalam Fungsi:
1. **Membaca Gambar**:
   
   image = np.array(Image.open(disk_dir / f"{image_id}.png"))
  
   - **Image.open(disk_dir / f"{image_id}.png")**: Membuka file gambar dengan ID yang diberikan dari direktori disk (`disk_dir`).
   - **np.array(...)**: Mengonversi gambar yang dibuka ke array numpy dengan dimensi (32, 32, 3).

2. **Membaca Label**:
   
   with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
       reader = csv.reader(
           csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
       )
       label = int(next(reader)[0])
       
   -open(disk_dir / f"{image_id}.csv", "r")**: Membuka file label `.csv` dengan ID yang sama dalam mode baca (`"r"`).
   - **csv.reader(...)**: Membuat reader untuk membaca file CSV. 
     - `delimiter=" "`: Mengatur pembatas antar kolom dalam CSV sebagai spasi.
     - `quotechar="|"`: Mengatur karakter kutipan sebagai `|`.
     - `quoting=csv.QUOTE_MINIMAL`: Menentukan bahwa hanya karakter yang mengandung karakter khusus akan di-quote.
   - **label = int(next(reader)[0])**: Membaca baris pertama dari CSV, yang berisi label gambar, dan mengonversinya menjadi integer.

3. **Mengembalikan Gambar dan Label**:
  
   return image, label
   
   - Mengembalikan tuple berisi array gambar (`image`) dan label (`label`)..

##Reading From LMDB

def read_single_lmdb(image_id):
    """ Stores a single image to LMDB.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Encode the key the same way as we stored it
        data = txn.get(f"{image_id:08}".encode("ascii"))
        # Remember it's a CIFAR_Image object that is loaded
        cifar_image = pickle.loads(data)
        # Retrieve the relevant bits
        image = cifar_image.get_image()
        label = cifar_image.label
    env.close()

    return image, label

Berikut adalah penjelasan rinci mengenai fungsi `read_single_lmdb` yang digunakan untuk membaca gambar dan label terkait dari LMDB:

### Definisi Fungsi `read_single_lmdb`

def read_single_lmdb(image_id):
    """ Reads a single image from LMDB.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3)
        label       associated meta data, int label
    """
    # Open the LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Encode the key the same way as we stored it
        data = txn.get(f"{image_id:08}".encode("ascii"))
        # Remember it's a CIFAR_Image object that is loaded
        cifar_image = pickle.loads(data)
        # Retrieve the relevant bits
        image = cifar_image.get_image()
        label = cifar_image.label
    env.close()

    return image, label


### Penjelasan Fungsi
- **Tujuan**: Membaca sebuah gambar dan label yang terkait dari database LMDB yang sebelumnya disimpan dengan metode penyimpanan LMDB (`store_single_lmdb`).
- **Parameter**:
  - `image_id`: ID unik untuk gambar yang ingin dibaca. ID ini digunakan untuk membangun kunci (key) yang digunakan dalam LMDB.

### Langkah-langkah dalam Fungsi:
1. **Membuka Environment LMDB**:
   
   env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)
   
   - **lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)**: Membuka environment LMDB di direktori `lmdb_dir` dengan nama `single_lmdb`. Mode `readonly=True` menunjukkan bahwa environment dibuka dalam mode baca saja.

2. **Memulai Transaksi Baca**:
   
   with env.begin() as txn:
  
   - **env.begin()**: Memulai transaksi baca. Transaksi ini memastikan bahwa data yang dibaca konsisten.

3. **Mengambil Data dari LMDB**:
   
  data = txn.get(f"{image_id:08}".encode("ascii"))
   
   - **txn.get(f"{image_id:08}".encode("ascii"))**: Mengambil data dari LMDB menggunakan kunci yang di-encode sebagai string ASCII. Kunci dibangun dari `image_id` dengan padding nol hingga 8 digit (`f"{image_id:08}"`).

4. **Deserialisasi Data**:
   
   cifar_image = pickle.loads(data)
   
   - **pickle.loads(data)**: Menggunakan pickle untuk mendeserialisasi data yang diambil dari LMDB kembali menjadi objek `CIFAR_Image`.

5. **Mengambil Gambar dan Label**:
   
   image = cifar_image.get_image()
   label = cifar_image.label
   
   - **cifar_image.get_image()**: Memanggil metode `get_image()` dari objek `CIFAR_Image` untuk mendapatkan array gambar.
   - **cifar_image.label**: Mengambil label yang tersimpan dalam objek `CIFAR_Image`.

6. **Menutup Environment LMDB**:
  
   env.close()
   
   - **env.close()**: Menutup environment LMDB setelah selesai digunakan.

7. **Mengembalikan Gambar dan Label**:
   
   return image, label
   
   - Mengembalikan tuple berisi array gambar (`image`) dan label (`label`).

## Reading From HDF5

def read_single_hdf5(image_id):
    """ Stores a single image to HDF5.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")

    image = np.array(file["/image"]).astype("uint8")
    label = int(np.array(file["/meta"]).astype("uint8"))

    return image, label

##membaca file hdfs
def read_single_hdf5(image_id):
    """ Stores a single image to HDF5.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")

    image = np.array(file["/image"]).astype("uint8")
    label = int(np.array(file["/meta"]).astype("uint8"))

    return image, label
```


1. ## Definisi Fungsi:
    
  def read_single_hdf5(image_id):
    
    - Fungsi `read_single_hdf5` didefinisikan dengan satu parameter, `image_id`, yang merupakan ID unik integer untuk gambar yang akan diambil dari file HDF5.

2. ##Docstring:
    
    """ Stores a single image to HDF5.
        Parameters:
        ---------------
        image_id    integer unique ID for image

        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    
    - Docstring ini menjelaskan bahwa fungsi ini bertujuan untuk menyimpan satu gambar ke dalam format HDF5. Docstring ini juga menjelaskan parameter input dan nilai pengembalian dari fungsi tersebut.

3. #Membuka File HDF5:
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")
    
    - Baris ini membuka file HDF5 dengan nama yang sesuai dengan `image_id` di direktori `hdf5_dir`. Mode `"r+"` digunakan untuk membuka file dalam mode read/write (baca/tulis).

4. **Membaca Gambar dari File HDF5:**

  image = np.array(file["/image"]).astype("uint8")
  
    - Baris ini mengambil dataset yang disimpan di dalam file HDF5 dengan nama `/image`, mengonversinya menjadi array numpy, dan mengubah tipe data menjadi `uint8`. Array ini diharapkan memiliki bentuk `(32, 32, 3)`, yaitu sebuah gambar RGB berukuran 32x32 piksel.

5. **Membaca Label dari File HDF5:**
    
  label = int(np.array(file["/meta"]).astype("uint8"))
    
    - Baris ini mengambil metadata yang disimpan di dalam file HDF5 dengan nama `/meta`, mengonversinya menjadi array numpy, mengubah tipe datanya menjadi `uint8`, lalu mengonversinya menjadi integer. Nilai ini mewakili label yang terkait dengan gambar.

6.##Mengembalikan Gambar dan Label:
    
  return image, label
    
    - Fungsi ini mengembalikan dua nilai: `image` (array gambar) dan `label` (label gambar).


## read singla function

_read_single_funcs = dict(
    disk=read_single_disk, lmdb=read_single_lmdb, hdf5=read_single_hdf5
)

1. disk=read_single_disk berarti bahwa fungsi read_single_disk akan dihubungkan dengan kunci string 'disk' dalam kamus _read_single_funcs.
2. lmdb=read_single_lmdb berarti bahwa fungsi read_single_lmdb akan dihubungkan dengan kunci string 'lmdb' dalam kamus _read_single_funcs.
4. hdf5=read_single_hdf5 brarti bahwa fungsi read_single_hdf5 akan dihubungkan dengan kunci string 'hdf5' dalam kamus _read_single_funcs.

#Experiment for Reading a Single Image

from timeit import timeit

read_single_timings = dict()

for method in ("disk", "lmdb", "hdf5"):
    t = timeit(
        "_read_single_funcs[method](0)",
        setup="image=images[0]; label=labels[0]",
        number=1,
        globals=globals(),
    )
    read_single_timings[method] = t
    print(f"Method: {method}, Time usage: {t}")

Potongan kode ini mengukur waktu yang dibutuhkan untuk membaca satu gambar beserta labelnya dari setiap metode penyimpanan yang tersedia, yaitu "disk", "lmdb", dan "hdf5". Berikut adalah penjelasan langkah demi langkah dan outputnya:

### Langkah-langkah:
1. *Iterasi melalui setiap metode penyimpanan:*
   python
   for method in ("disk", "lmdb", "hdf5"):

   - Ini adalah loop yang mengulangi setiap metode penyimpanan yang tersedia.

2. *Mengukur waktu eksekusi untuk membaca gambar:*
   python
   t = timeit(
       "_read_single_funcs ",
       setup="image=images[0]; label=labels[0]",
       number=1,
       globals=globals(),
   )

   - timeit() digunakan untuk mengukur waktu eksekusi dari pemanggilan fungsi membaca satu gambar menggunakan metode yang sedang diuji.
   - Pernyataan yang diukur adalah `_read_single_funcs `, yang akan memanggil fungsi membaca gambar yang sesuai berdasarkan metode.
   - setup="image=images[0]; label=labels[0]" digunakan untuk mendefinisikan variabel image dan label yang akan digunakan dalam pernyataan yang diukur. Variabel tersebut diisi dengan gambar pertama dan label pertama dari data yang dimuat.
   - number=1 menunjukkan bahwa pernyataan akan dijalankan sekali.

3. *Menyimpan hasil pengukuran waktu:*
   python
   read_single_timings[method] = t

   - Waktu eksekusi untuk setiap metode disimpan dalam kamus read_single_timings dengan kunci yang sesuai.

4. *Mencetak waktu eksekusi untuk setiap metode:*
   python
   print(f"Method: {method}, Time usage: {t}")

   - Ini mencetak metode penyimpanan yang sedang diuji bersama dengan waktu eksekusinya.

### Output (contoh):

Method: disk, Time usage: 0.123456
Method: lmdb, Time usage: 0.234567
Method: hdf5, Time usage: 0.345678


#Reading Many Images

Adjusting the Code for Many Images

def read_many_disk(num_images):
    """ Reads image from disk.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []

    # Loop over all IDs and read each image in one by one
    for image_id in range(num_images):
        images.append(np.array(Image.open(disk_dir / f"{image_id}.png")))

    with open(disk_dir / f"{num_images}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for row in reader:
            labels.append(int(row[0]))
    return images, labels

def read_many_lmdb(num_images):
    """ Reads image from LMDB.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), readonly=True)

    # Start a new read transaction
    with env.begin() as txn:
        # Read all images in one single transaction, with one lock
        # We could split this up into multiple transactions if needed
        for image_id in range(num_images):
            data = txn.get(f"{image_id:08}".encode("ascii"))
            # Remember that it's a CIFAR_Image object 
            # that is stored as the value
            cifar_image = pickle.loads(data)
            # Retrieve the relevant bits
            images.append(cifar_image.get_image())
            labels.append(cifar_image.label)
    env.close()
    return images, labels

def read_many_hdf5(num_images):
    """ Reads image from HDF5.
        Parameters:
        ---------------
        num_images   number of images to read

        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []

    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "r+")

    images = np.array(file["/images"]).astype("uint8")
    labels = np.array(file["/meta"]).astype("uint8")

    return images, labels

_read_many_funcs = dict(
    disk=read_many_disk, lmdb=read_many_lmdb, hdf5=read_many_hdf5
)

Berikut adalah penjelasan singkat langkah demi langkah dari potongan kode di atas:

1. *Fungsi read_many_disk:*
   - Membaca sejumlah gambar dan labelnya dari disk.
   - Membuka setiap gambar secara individu menggunakan iterasi melalui ID gambar.
   - Membuka file CSV yang berisi label-label tersebut.
   - Mengembalikan larik gambar dan larik label.

2. *Fungsi read_many_lmdb:*
   - Membaca sejumlah gambar dan labelnya dari LMDB.
   - Membuka lingkungan LMDB yang sesuai dengan jumlah gambar yang akan dibaca.
   - Memulai transaksi baca.
   - Mengambil data dari LMDB untuk setiap gambar.
   - Mengembalikan larik gambar dan larik label.

3. *Fungsi read_many_hdf5:*
   - Membaca sejumlah gambar dan labelnya dari file HDF5.
   - Membuka file HDF5 yang sesuai dengan jumlah gambar yang akan dibaca.
   - Membaca dataset gambar dan label dari file HDF5.
   - Mengembalikan larik gambar dan larik label.

4. *Kamus _read_many_funcs:*
   - Kamus ini memetakan nama metode penyimpanan ("disk", "lmdb", "hdf5") ke fungsi-fungsi yang sesuai untuk membaca sejumlah gambar dan labelnya dari masing-masing metode penyimpanan.

Experiment for Reading Many Images


from timeit import timeit

read_many_timings = {"disk": [], "lmdb": [], "hdf5": []}

for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_read_many_funcs[method](num_images)",
            setup="num_images=cutoff",
            number=1,
            globals=globals(),
        )
        read_many_timings[method].append(t)

        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, No. images: {cutoff}, Time usage: {t}")


Berikut adalah penjelasan singkat langkah demi langkah dari potongan kode di atas:

1. *Iterasi melalui nilai-nilai cutoff:*
   python
   for cutoff in cutoffs:

   - Loop ini mengulangi setiap nilai cutoff yang telah ditentukan sebelumnya.

2. *Iterasi melalui metode penyimpanan:*
   python
   for method in ("disk", "lmdb", "hdf5"):

   - Loop ini mengulangi setiap metode penyimpanan yang tersedia, yaitu "disk", "lmdb", dan "hdf5".

3. *Mengukur waktu untuk membaca banyak gambar dan label:*
   python
   t = timeit(
       "_read_many_funcs[method](num_images)",
       setup="num_images=cutoff",
       number=1,
       globals=globals(),
   )

   - timeit() digunakan untuk mengukur waktu eksekusi dari pemanggilan fungsi untuk membaca banyak gambar dan label menggunakan metode yang sedang diuji.
   - Pernyataan yang diukur adalah _read_many_funcs[method](num_images), yang akan memanggil fungsi membaca banyak gambar dan label yang sesuai berdasarkan metode.
   - setup="num_images=cutoff" digunakan untuk menyiapkan jumlah gambar yang akan dibaca sesuai dengan nilai cutoff yang sedang diuji.
   - number=1 menunjukkan bahwa pernyataan akan dijalankan sekali.

4. *Menyimpan hasil pengukuran waktu:*
   python
   read_many_timings[method].append(t)

   - Waktu eksekusi untuk setiap metode dan setiap nilai cutoff disimpan dalam kamus read_many_timings dengan kunci yang sesuai.

5. *Mencetak informasi tentang metode, jumlah gambar, dan waktu eksekusi:*
   python
   print(f"Method: {method}, No. images: {cutoff}, Time usage: {t}")

   - Ini mencetak informasi tentang metode penyimpanan yang sedang diuji, jumlah gambar yang sedang diproses, dan waktu eksekusi yang diukur.

#A More Critical Look at Implementation

# Slightly slower
for i in range(len(dataset)):
    # Read the ith value in the dataset, one at a time
    do_something_with(dataset[i])

# This is better
data = dataset[:]
for d in data:
    do_something_with(d)

Potongan kode tersebut adalah contoh penggunaan slicing dalam Python untuk mengoptimalkan iterasi melalui suatu dataset. Berikut penjelasan singkatnya:

1. *Iterasi dengan Indeks:*
   python
   for i in range(len(dataset)):
       do_something_with(dataset[i])

   - Ini adalah cara tradisional untuk mengiterasi melalui setiap elemen dalam dataset dengan menggunakan indeks.
   - Pada setiap iterasi, nilai indeks digunakan untuk mengakses elemen dataset menggunakan indexing.
   - Metode ini cukup lambat karena pada setiap iterasi, Python harus mengakses elemen dataset menggunakan indeks.

2. *Iterasi dengan Slicing:*
   python
   data = dataset[:]
   for d in data:
       do_something_with(d)
   ```
   - Ini adalah cara yang lebih baik dan lebih efisien untuk mengiterasi melalui setiap elemen dalam dataset.
   - dataset[:] digunakan untuk membuat salinan dataset secara keseluruhan.
   - Salinan dataset kemudian disimpan dalam variabel data.
   - Iterasi dilakukan melalui data, yang merupakan salinan lengkap dari dataset.
   - Dengan menggunakan slicing, Python tidak perlu mengakses elemen dataset menggunakan indeks pada setiap iterasi, yang membuatnya lebih cepat dan lebih efisien.